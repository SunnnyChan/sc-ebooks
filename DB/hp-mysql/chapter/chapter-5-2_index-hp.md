# 高性能索引的策略

## 独立的列
```md
是指索引列不能是表达式的一部分，也不能是函数参数。

如：
mysql> SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
mysql> SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;

以上查询都不能使用索引，我们应该养成习惯始终将索引列单独放在比较符号的一侧。

可以做以下优化：
mysql> SELECT ... WHERE date_col >= DATE_SUB(CURRENT_DATE, INTERVAL 10 DAY);

但是 对当前日期的引用将防止查询缓存对结果进行cache，可以用文字替换当前日期来解决这个问题：
mysql> SELECT ... WHERE date_col >= DATE_SUB('2008-01-17', INTERVAL 10 DAY);
```
## [前缀索引和索引选择性](chapter-5/Prefix-Indexes-and-Index-Selectivity.md)

## [多列索引](chapter-5/Mutil-Column-Index.md)

## [聚簇索引（Clustered Indexes）](chapter-5/Clustered-Indexes.md)

## [覆盖索引（Covering Indexes）](chapter-5/Covering-Indexes.md)

## 使用索引扫描来做排序（Using Index Scans for Sorts）
```md
MySQL 有两种方式生成有序结果：通过排序操作，或者按照索引顺序扫描。
如果 EXPLAIN 的 type列 值为“index”，则说明使用了索引扫描来做排序。

扫描索引本身很快，但如果不能覆盖查询所有的列，就不得不没扫描一条索引记录就回表插叙一次对应的行。
这基本上就是随机IO，因此此时按索引顺序读取数据的速度通常要比顺序地全表扫描慢，
尤其是在IO密集型的工作负载时。

MySQL 可以使用同一个索引既满足 排序 又用于查找。
因此，如果可能，设计索引时应该尽量满足这两种任务。

只有当索引的列顺序和ORDER BY 子句的顺序完全一致，并且所有列的排序方向都一样时，
MySQL才能使用索引来对结果做排序。

如果查询需要关联多张表，则只有当ORDER BY 子句引用的字段全部为第一个表时，才能使用索引做排序。
ORDER BY 子句需要满足索引的最左前缀要求，否则不能使用索引排序。

当前导列为常量时，ORDER BY 子句可以不用满足最左前缀要求。
如果 WHERE 子句 或 JOIN 子句中这些列指定了常量，就可以“弥补”索引的不足。

```
## 压缩（前缀压缩）索引（Packed (Prefix-Compressed) Indexes）
```md
MyISAM 使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大提升性能。
默认值压缩字符串，通过参数设置也可以对整数做压缩。
```
## 冗余和重复索引（Redundant and Duplicate Indexes）
```md
重复索引是指在相同的列上按照相同的顺序创建相同类型的索引。

MySQL允许在相同列上创建多个索引。
会单独维护每个索引，且优化器在优化查询时也需要逐个地进行开率，因此重复索引的存在会影响性能。
```
## 未使用的索引
```md
长期为使用的索引，纯粹是浪费资源，需要及时删除。
```
* Percona Toolkit 中的pt-index-usage 
```md
可以读取查询日志，并对日志中的每条查询做EXPLAIN，
然后打印出关于索引和查询的报告。

不仅可以找出哪些索引未使用，还可以了解查询的执行计划：
在某些情况下有些类似的查询执行的方式不一样
还可以定位到那些偶尔服务质量差的查询，优化它们以得到一致的性能表现。

结果还可以写入MySQL的表中，方便查询。
```
## [索引和锁 （Indexes and Locking）](chapter-5/Indexes-and-Locking.md)

## 总结（Summary of Indexing Strategies ）
```md
最重要的是检查最经常运行的查询，但也应该考虑不太频繁的操作，比如插入和更新数据。
尽量避免在不知道哪些查询将使用索引的情况下创建索引的常见错误。考虑所有索引是否一起构成最佳配置。
```
```md
有时您可以只查看查询，查看它们需要哪些索引，然后添加它们，然后就完成了。
但是，有时您会有足够多的不同类型的查询，您无法为它们添加完美的索引，因此您需要做出妥协。
为了找到最佳的平衡，您应该进行基准测试和概要分析。

首先要看的是响应时间，考虑为任何花费时间太长的查询添加索引，
然后检查导致最多负载的查询(有关如何度量负载的更多信息，请参见第2章)，并添加索引来支持它们。
（如果您的系统正在接近内存、CPU或磁盘瓶颈，请考虑这一点。）
例如，如果您执行许多长聚合查询来生成摘要，那么您的磁盘可能会受益于覆盖支持查询分组的索引。
```
```md
在可能的情况下，尝试扩展现有的索引，而不是添加新的索引。
维护一个多列索引通常比维护多个单列索引更有效。
如果您还不了解查询分布，请尽量使索引具有选择性，因为具有高度选择性的索引通常更有益。
```